\section{Literature Review}
\hl{My literature review consists of two parts that I believe to be important to my research question. It first describes different implementations of Procedural Interior Generation (PCIG) then explores ways in which Artificial Intelligence (AI) is compared to Humans.}

\subsection{Implementations of Procedural Interior Generation}
Although PCG has a lot to show and offer in game development \hl{- being used for characters, terrain, weapons and textures -} the use of Procedural Interior Generation (PCIG) in games however is scarcely come by.
\\
A game that does use PCIG is Catlateral Damage \cite{game:catlateral},
a small indie game developed by Manekoware where you play as a cat on a destructive rampage 
in its own house. In 2017, Chris Chung (the indie developer behind the game) wrote a case study about the level design in his game \cite{what-is-pcg}. When developing Catlateral Damage, Chung was undecided on how to design the levels and ultimately went for PCIG\cite{pcg_in_gd}. Before the interior decoration can take place, a Squarified Treemap algorithm is used to generate the room layouts and floor plans within the level \cite{squarified-treemap}. Each room generated from this algorithm has an associated data file, this file contains the type of furniture available, maximum type of each furniture, spawn probabilities, if the furniture is placeable on walls and if the player will spawn there. The furniture objects that can be placed have physics components attached, to allow them to be accurately placed within the level - for this, a Rectangle Packing algorithm is used to place these objects within allocated surface areas on the floor and other furniture objects. Concluding the case study, Chung states that most players could not notice that the levels were procedurally generated - \hl{although this is a promising statement, Chung has not shown any evidence to back this claim.}

\bigskip
On 29th April 2021, Sony Interactive Entertainment published patent US20210121781, titled "AI-Generated Internal Environments Based On External Geometry" \cite{sony-patent}. The patents' description goes onto explain a Machine Learning (ML) tool that takes in data from the external structure of a virtual building and generates an interior environment just from this data. \hl{Although this is just a patent for an ML tool, this could be the start of PCIG being used in AAA Titles. }
\bigskip


Despite there not being many implementations of PCIG in games, there are however a handful of published papers that have used their own techniques to emulate room interiors.
\subsubsection*{Multi-Agent System}
In 2009, T. Germer and M.Schwarz sought out to procedurally arrange a rooms' furniture in real-time. \cite{real-time-walkthroughs}. A demonstration of this system can be found on YouTube, uploaded by T. Germer himself \cite{youtube:real-time-walkthroughs}. This system involves a Multi-Agent based solution where each furniture object, in a given room, is seen as an individual agent that seeks a suitable parent furniture object. These agents have custom semantic descriptions to allow them to create different object layouts, an example listed by the authors is a chair - a chair can either be set next to a table/desk but can also be isolated in its own surroundings leading it to have many possible parent objects \cite{real-time-walkthroughs}.\\
Each agent has 3 states:
\begin{enumerate}
    \item Search
        \begin{itemize}
            \item All agents start in this state, they begin by searching for possible parent objects - if a parent is found that suits its semantics the agents' state changes to \textit{Arrange}, if a parent can't be found at all the agent is deleted. Different parts of the room are set as the root parent for agents - floor, walls, windows and doors.
        \end{itemize}
    \item Arrange
        \begin{itemize}
            \item In the \textit{Arrange} state, the agent attempts to place and orient itself with the parent accordingly. Whilst doing so, it has to check for collisions with other agents in which the Separating Axis Thereom is used \cite{separating-axis-thereom} - if no collisions are found the agents' state changes to \textit{Rest}.
        \end{itemize}
    \item Rest
        \begin{itemize}
            \item In the \textit{Rest} state, potential child agents are now able to seek this object as a parent. If the resting agents parent moves, the resting agent will move along with it - however if this move results in a collision, its parent is lost and the agents state is changed back to \textit{Search}.
        \end{itemize}
\end{enumerate}
Before using this system, it requires a certain degree of user input \cite{real-time-walkthroughs}. Firstly, each room would need to have specific data such as labelled parts of the room (windows, floor, doors), how many objects, what type of objects and how many of these types can be used in this room.
A user is also required to write the semantic description of each type of object - this includes object clearance distance, possible orientation values and potential parents (and what sides to correspond with).
Due to the parents of each object being manually set by the user in their semantic descriptions, a hierarchy is not explicitly defined - yet handled at run-time by the system just before the agents are initialised \cite{real-time-walkthroughs}.

\hl{Although a large proportion of the rooms furnishing is handled by the agents themselves, a big drawback is that each agent must have a manually defined semantic description. This could cause a lot of issues especially if many types of objects are to be used in a room.}

\subsubsection*{Rule-Based Layout}
A Rule-Based layout approach was proposed in 2009, this method would focus on user defined rules and layouts \cite{rule-based-layout}. Users would be able to specify what objects can be placed within a layout - these would represent an instance of a class and contain certain rules on how it should behave when being placed.

The relationships between different objects could be explicitly and implicitly defined. A user is able to explicitly create a rule in an objects class or use features. An example of explicitly defining a relationship, as told by the authors, is by setting rule for the sofa class to always face an instance of the TV class \cite{rule-based-layout}.
An implicitly defined relationship uses feature types. Feature types can be used for checking what objects should and should not overlap. These are used as tags and are applied to specific parts of objects - for example an \textit{OffLimit} feature type tag would be used for the bounding box of most objects \cite{rule-based-layout}.

Rules can be defined in multiple ways too. They can be associated specifically with an object class, this would mean that this rule only applies to this class and any instances of it.
Another way is by defining rules in the layout planner - this would help with objects that general rules may not be applicable to. An example listed by the authors is a chair in a meeting room, this type of object is usually sat against a wall - so this rule would be applied in a "Waiting Room" layout \cite{rule-based-layout}.

The layout planner is responsible for sending objects to the layout solver. As stated before, the planner can have custom rules itself to allow it to be applicable to different room layouts (living room, factory floor, waiting room). It also has a backtracking rule that is only triggered if an object of interest is not placeable. If this is the case, the planner would backtrack to place previous objects in different positions to allow this object to be placed.

The layout solver is given an object from the planner and the type of layout (dependent if a user has applied rules to the planner). Within this layout it finds all possible locations for the new object - these possible locations are initially based upon the set rules of the object and the rules already set in place for existing objects in the layout. The possible locations then take into account specific feature types, such as the amount of clearance an object requires or the \textit{OffLimit} tag that was mentioned earlier \cite{rule-based-layout}. A Minkowski Sum \cite{minkowski} is carried out containing these inaccessible areas and removed from the list of possible locations.
With this completed, the object is then given a list of all possible locations in the layout it can be placed.

\hl{Something good. Something bad.}

\subsubsection*{Constraints}
In 2017 P. Henderson, K. Subr and V. Ferrari presented a data driven model that learns from the SUNCG \cite{suncg} database to generate furniture layouts \cite{constrained-layouts}. This database contains over 45000 apartment layouts that are designed by humans, from this 45000 - 2500 CAD models are categorised into furniture, these models are then assigned an object class of which there is 170 of (television, bed, table).
Their model is presented in such a way that it can be left to be fully automated \cite{constrained-layouts}, but does allow flexibility with the user allowing them to change constraints within the layout.\\
These constraints include:
\begin{itemize}
    \item Room size, shape \& type 
    \item Exclusion of Object classes
    \item Furniture clearance 
    \item Locations of specified furniture
    \item Locations of doors \& windows
\end{itemize}
Upon generating layouts, the results varied dependent on the set constraints applied to the room. Layouts that had no set constraints were found to be generating in 0.04 seconds on average \cite{constrained-layouts}. Whereas layouts that did have constraints applied, generated anywhere between 0.04-112 seconds on average \cite{constrained-layouts}. This large difference in generation times drastically varies solely on what constraints applied -  room size, object exclusion and clearance constraints all generated in 0.04 seconds on average, whereas the combination of room size and the locations of doors \& windows took around 112 seconds to generate.

A user study was carried out in their paper, where 1400 pairs of layouts are presented to 8 non-experts in an image format \cite{constrained-layouts}. These participants are asked to identify the layout that has a more realistic/natural setting. In each pair one layout is from their model, the other being human designed - the order in which these images are shown are randomised per pair.
In this study, both constrained and unconstrained layouts are put to the test. For unconstrained layouts, they were presented in 2 different styles; 1st person and an overhead view. Layouts that were presented in 1st person, were seen to be slightly preferred over the human designs and those presented overhead were seen to be indistinguishable from human designs.
Constrained layouts were only presented in an overhead format, but two sets of constraints were used:
\begin{enumerate}
    \item[i.] Fixed room size \& fixed placement of a singular object
    \item[ii.] Fixed room size \& fixed door/window locations
\end{enumerate}
With the constrained layouts of (i), the model layouts were seen to be indistinguishable from those of human design. Whereas the layouts of (ii), human designs were preferred over the models.

\hl{Something good. Something user study. Something bad.}

\subsubsection*{Statistical Relationships}
Paper \cite{make-it-home}
Simulated annealing \cite[Chapter~3]{simulated-annealing}
M-H algorithm \cite{understanding-mh-algorithm}

\subsection{Artificial Intelligence Compared to Humans}
This is going to be a little more difficult to write about, as I haven't read a paper on this so far. And I have only managed to find 3 papers that talk about this, but I am not sure that they could be entirely relevant.